package proj4;

/**
 * @author Rachael Birky
 * @version 
 * 
 * <p> Project4.java
 * <p> This class simulates TicTacToe games
 * 		between two players (random and learning AI)
 * 		and prints the statistics of the games played.
 */
public class Project4 {

	private int numRandomWins = 0;
	private int numSmartWins = 0;
	private int numDraws = 0;
	private int numGames = 0;

	private RandomAI randomPlayer;
	private SmartPlayer smartPlayer;

	public Project4(){
		
	}

	public void play(RandomAI aRandomPlayer, SmartPlayer aSmartPlayer, int aNumGames){

		numGames = aNumGames;
		randomPlayer = aRandomPlayer;
		smartPlayer = aSmartPlayer;
		int smartNum = smartPlayer.getPlayerNum();


		for (int i =0; i<aNumGames; i++){
			TicTacToe theBoard = new TicTacToe();
			smartPlayer.newGame(smartNum);

			//smart plays first
			if (smartPlayer.getPlayerNum() == 1){
				while(!theBoard.isOver()){
					smartPlayer.move(theBoard);
					randomPlayer.move(theBoard);
				}
			}

			//random plays first
			if(smartPlayer.getPlayerNum() == 2){
				while(!theBoard.isOver()){
					randomPlayer.move(theBoard);
					smartPlayer.move(theBoard);
				}
			}

			// checking that smart player is O -- works!
			int winner = theBoard.getWinner();
			if (winner == smartNum) {numSmartWins++;}
			else if (winner == 0) {numDraws++;}
			else {numRandomWins++;}

		}
		printResults();
	}

	public void printResults(){
		
		int numSmartCollisions = smartPlayer.getNumCollisions();
		int numSmartEntries = smartPlayer.getNumEntries();
		int numSmartSlots = smartPlayer.getNumSlots();
		
		int percentSmartWins = (int) (((double)numSmartWins/numGames)*100);
		int percentRandomWins = (int) (((double)numRandomWins/numGames)*100);
		
		int percentFull = (int) ((double)(numSmartEntries)/numSmartSlots*100);

		//accesses the hash table!
		System.out.println("FINAL REPORT:");
		System.out.println("The number of slots is: "+numSmartSlots);
		System.out.println("The number of entries is: "+numSmartEntries);
		System.out.println("The % full is: "+percentFull);
		System.out.println("The number of collisions is: "+numSmartCollisions);

		System.out.println("Smart Player has won " +numSmartWins+ " times, which is "+percentSmartWins+" percent");
		System.out.println("Random AI has won " +numRandomWins+ " times, which is "+percentRandomWins+" percent");
    
		//smart player suggestions; accesses the hashtable!
		TicTacToe favFirstMove = smartPlayer.favFirstMove();
		int numFavWon = smartPlayer.numFavWon();
		int numFavPlayed = smartPlayer.numFavPlayed();
		int percentFavWon = (int) ((double)(numFavWon)/numFavPlayed*100);
		System.out.println("My favorite first move is: \n\n"+favFirstMove);
		System.out.println("Won "+numFavWon+" out of "+numFavPlayed+", which is "+percentFavWon+"%");
		
		//smartPlayer.printFirstMoves();
	}

	public static void main(String[] args){
		Project4 test = new Project4();
		RandomAI player1 = new RandomAI();
		SmartPlayer player2 = new SmartPlayer(1);
		test.play(player1, player2, 1000);
	}

}

********************


package proj4;

/**
 * @author Rachael Birky
 * @version 
 * 
 * <p> Project4.java
 * <p> This class simulates TicTacToe games
 * 		between two players (random and learning AI)
 * 		and prints the statistics of the games played.
 */
public class Project4 {

	private int numRandomWins = 0;
	private int numSmartWins = 0;
	private int numDraws = 0;
	private int numGames = 0;

	private RandomAI randomPlayer;
	private SmartPlayer smartPlayer;

	public Project4(){

	}

	//change to player objects
	//write superclass, then "extends Player" in files?
	//store players to access info about hash table?
	public void play(RandomAI aRandomPlayer, SmartPlayer aSmartPlayer, int aNumGames){

		numGames = aNumGames;
		randomPlayer = aRandomPlayer;
		smartPlayer = aSmartPlayer;
		int smartNum = smartPlayer.getPlayerNum();


		for (int i =0; i<aNumGames; i++){
			TicTacToe theBoard = new TicTacToe();
			smartPlayer.newGame(smartNum);

			//smart plays first
			if (smartPlayer.getPlayerNum() == 1){
				while(!theBoard.isOver()){
					smartPlayer.move(theBoard);
					theBoard.printBoard();
					System.out.println();
					randomPlayer.move(theBoard);
					theBoard.printBoard();
					System.out.println();
				}
			}

			//random plays first
			if(smartPlayer.getPlayerNum() == 2){
				while(!theBoard.isOver()){
					randomPlayer.move(theBoard);
					theBoard.printBoard();
					System.out.println();
					smartPlayer.move(theBoard);
					theBoard.printBoard();
					System.out.println();
				}
			}

			// checking that smart player is O -- works!
			int winner = theBoard.getWinner();
			if (winner == smartNum) {numSmartWins++; System.out.println("winner: "+smartPlayer+"\n***********");}
			else if (winner == 0) {numDraws++; System.out.println("draw!"+"\n***********");}
			else {numRandomWins++; System.out.println("winner: "+randomPlayer+"\n***********");}

		}

		printResults();
	}

	public void printResults(){

		int numSmartCollisions = smartPlayer.getNumCollisions();
		int numSmartEntries = smartPlayer.getNumEntries();
		int numSmartSlots = smartPlayer.getNumEntries();
		
		int percentSmartWins = (int) (((double)numSmartWins/numGames)*100);
		int percentRandomWins = (int) (((double)numRandomWins/numGames)*100);
		int percentFull = (int) (((double)numSmartEntries/numSmartSlots)*100);

		//accesses the hash table!
		System.out.println("FINAL REPORT:");
		System.out.println("The number of slots is: "+numSmartSlots);
		System.out.println("The number of entries is: "+numSmartEntries);
		System.out.println("The % full is: "+percentFull);
		System.out.println("The number of collisions is: "+numSmartCollisions);

		System.out.println("Smart Player has won " +numSmartWins+ " times, which is "+percentSmartWins+" percent");
		System.out.println("Random AI has won " +numRandomWins+ " times, which is "+percentRandomWins+" percent");

		//smart player suggestions; accesses the hashtable!
		System.out.println("My favorite first move is: ");
		System.out.println("Won * our of *, which is *%");
	}

	public static void main(String[] args){
		Project4 test = new Project4();
		RandomAI player1 = new RandomAI();
		SmartPlayer player2 = new SmartPlayer(1);
		test.play(player1, player2, 1000);
	}

}



********************

package proj4;


import java.util.ArrayList;
import java.util.Random;

/**
 * @author Rachael Birky
 * @version 04.23.14
 * 
 * <p> SmartPlayer.java
 * <p> This class represents a "smart" TicTacToe player.
 * 		It keeps track of moves it has already made using a hash table,
 * 		and tries to choose the next move that results in the most wins,
 * 		least losses, or random.
 */
public class SmartPlayer {

	boolean debug = true;

	Random generator = new Random();

	private int PLAYER_NUM;

	//stores keys
	private ArrayList<TicTacToe> thisGame = new ArrayList<TicTacToe>();

	private HashTable<TicTacToe, Stats> boards = new HashTable<TicTacToe, Stats>(283);


	public SmartPlayer(int playerNum){
		PLAYER_NUM = playerNum;
	}

	private int getNumSuccessors(TicTacToe t){
		return t.numEmpty();
	}
	
	private TicTacToe[] getSuccessors(TicTacToe t){
		TicTacToe tCopy1 = new TicTacToe(t);
		int numSuccessors = t.numEmpty();
		TicTacToe[] successors = new TicTacToe[9];

		int index=0;
		for(int i=0; i<tCopy1.length; i++){
			for(int j=0; j<tCopy1.length; j++){
				if (tCopy1.playerAt(i, j) == 0){
					tCopy1.move(i,j);
					TicTacToe tCopy2 = new TicTacToe(t);
					tCopy2.move(i, j);
					successors[index] = tCopy2;
					index++;
				}
			}
		}
//		return boards.get(t).getSuccessors();
		return successors;
	}

	public void move(TicTacToe t){

		TicTacToe tCopy = new TicTacToe(t);

		int numSuccessors = getNumSuccessors(tCopy);
		TicTacToe[] successors = getSuccessors(tCopy);

		//if zero successors, game is over, so skip all this!
		if(numSuccessors>0){
			TicTacToe nextMove = null;
			int maxScore = 0;
			ArrayList<TicTacToe> tiedBoards = new ArrayList<TicTacToe>();

			//store successors in hash table to access statistics later
			for(int i=0; i<numSuccessors; i++){
				//hash table prevents duplicates
				boards.put(successors[i], new Stats(successors[i]));

				//compare to current max score
				if (boards.get(successors[i]).getPercentWin() > maxScore){
					maxScore = boards.get(successors[i]).getPercentWin();
					nextMove = successors[i];
				}
			}
			
			//put all with same score into an array
			for(int i=0; i<numSuccessors; i++){
				if(boards.get(successors[i]).getPercentWin() == maxScore)
					tiedBoards.add(successors[i]);
			}

			//break tie if need be
			if(tiedBoards.size()>1){
				nextMove = tiedBoards.get(generator.nextInt(tiedBoards.size()));
			}
			else if (tiedBoards.size()==1){
				nextMove = tiedBoards.get(0);
			}
			
			//calculate the spot to move by finding difference, and actually move...
			int row=0; int col=0;
			for (int i=0; i<nextMove.length; i++){
				for (int j=0; j<nextMove.length; j++){
					if (nextMove.playerAt(i, j) != t.playerAt(i, j))
					{row = i; col = j;}
				}
			}
			t.move(row, col);

			//store resulting board in thisGame and hashTable
			TicTacToe result = new TicTacToe(t);
			thisGame.add(result);
			
			//storing duplicates?
			if(boards.containsKey(result)){
				System.out.println("FOUND!");
				boards.get(result).incrementNumSeen();
			}
			else{
				System.out.println("Not Found :(!");
				boards.put(result, new Stats(result));
				boards.get(result).incrementNumSeen();
			}
		}
	}

	public void endGame(TicTacToe finalBoard){
		int winner = finalBoard.getWinner();
		System.out.println("winner num: "+winner);
		System.out.println("this player: "+PLAYER_NUM);

		if (winner == PLAYER_NUM){
			for (TicTacToe aBoard : thisGame){
				boards.get(aBoard).incrementNumWins();
				if (debug) {System.out.println("wins"+boards.get(aBoard).getNumWins());}
			}
		}
		else if(winner == 0){
			for (TicTacToe aBoard : thisGame){
				boards.get(aBoard).incrementNumDraws();
				if (debug) {System.out.println("draws"+boards.get(aBoard).getNumDraws());}
			}
		}
		else{
			for (TicTacToe aBoard : thisGame){
				boards.get(aBoard).incrementNumLosses();
				if (debug) {System.out.println("losses"+boards.get(aBoard).getNumLosses());}
			}
		}

		for (TicTacToe aBoard : thisGame){
			if (debug) {System.out.println("wins,losses,draws,numplayed:"+boards.get(aBoard).getNumWins()+","+boards.get(aBoard).getNumLosses()+","+boards.get(aBoard).getNumDraws()+","+boards.get(aBoard).getNumPlayed());}
		}
		
		thisGame = new ArrayList<TicTacToe>();
	}

	public void newGame(int player){
		PLAYER_NUM = player;
		thisGame.clear();
	}

	public int numberOfTimesSeen(TicTacToe t){
		Stats thisStat = boards.get(t);
		int numSeen = thisStat.getNumSeen();
		return numSeen;
	}

	public int getNumSlots(){
		return boards.numSlots();
	}

	public int getNumEntries(){
		return boards.numEntries();
	}

	public int getNumCollisions(){
		return boards.numCollisions();
	}

	public int getPlayerNum(){
		return this.PLAYER_NUM;
	}

	public String toString(){
		return "Smart Player";
	}

	public void printHashTable(){
		boards.printHashTable();
	}

	public void printThisGame(){
		for (TicTacToe aBoard : thisGame)
			System.out.println(aBoard);
	}

	public static void main(String[] args){

		RandomAI p1 = new RandomAI();
		SmartPlayer p2 = new SmartPlayer(2);
		
		for(int i = 0; i<50; i++){
			TicTacToe aBoard = new TicTacToe();

			
			aBoard.move(0, 0);
			aBoard.printBoard();
			System.out.println();
			
			while(!aBoard.isOver()){
				p2.move(aBoard);
				aBoard.printBoard();
				System.out.println();
				p1.move(aBoard);
				aBoard.printBoard();
				System.out.println();
			}
			p2.endGame(aBoard);
			p2.printHashTable();
			System.out.println("*********");
		}
		
		p2.printHashTable();
		
	}

}


*************
package proj4;

/**
 * @author Rachael Birky
 * @version 04.23.14 
 * 
 * <p> TicTacToe.java
 * <p> This class represents a game of TicTacToe. 
 * 		The first player (X) is player 1, the second player (O) is player 2. 
 * 		Moves are indexed starting at zero.
 */
public class TicTacToe {

	private final int DRAW = 0;
	private final int PLAYER_1 = 1;
	private final int PLAYER_2 = 2;

	private final String PLAYER_1_MARK = "X";
	private final String PLAYER_2_MARK = "O";

	private int[][] board = new int[3][3];
	public int length = 3;

	private int winner = 0;
	private int turnNum = 1;
	private boolean isOver = false;

	public TicTacToe(){
		for (int i=0; i<board.length; i++)
			for (int j=0; j<board.length; j++){
				board[i][j] = 0;
			}
	}

	/**
	 * <p> Method:  move
	 * <p> Description: given a spot on the board,
	 * 			places the appropriate marker 
	 * @param row, col - space at which to move
	 * @return true if the move was successful
	 */
	public boolean move(int row, int col){
		if (this.isOver() || board[row][col]!=0)
			//cannot move if the game if over or the spot is taken
			return false;

		int player;

		if (turnNum%2==0)
			//player 2's turn
			player = PLAYER_2;
		else
			player = PLAYER_1;

		board[row][col] = player;

		//evaluate board each time for winner / game over
		evalWinner(row, col, player);

		turnNum++;

		//move successful
		return true;
	}

	/**
	 * <p> Method: evalWinner  
	 * <p> Description:  called ever time a move has been made,
	 * 			evaluated whether the player that last played has won
	 * @param row, col, player - the space last played, and who played there
	 * @return none
	 */
	private void evalWinner(int row, int col, int player){

		boolean onDiagonal = ((row==col) || (row==col+2) || (col==row+2));

		boolean winHorizontal = true;
		boolean winVertical = true;
		boolean winDiagonal1 = true;
		boolean winDiagonal2 = true;		

		//check horizontal
		for (int i=0; i<board.length; i++){
			if (board[row][i] != player) winHorizontal = false;
		}

		//check vertical
		for (int i=0; i<board.length; i++){
			if (board[i][col] != player) winVertical = false;
		}

		if(onDiagonal){
			for (int i=0; i<board.length; i++){
				//diagonal to right
				if(board[i][i] != player) winDiagonal1 = false;
				//diagonal to left
				if(board[i][-1*i+(board.length-1)] != player) winDiagonal2 = false;
			}
		}
		else{
			//not on diagonal; be sure to set diagonal win to false!
			winDiagonal1 = false;
			winDiagonal2 = false;
		}

		if (winHorizontal || winVertical || winDiagonal1 || winDiagonal2){
			winner = player;
			isOver = true;
		}

	}

	/**
	 * <p> Method:  getWinner
	 * <p> Description:  returns the number of the player that has
	 * 			won on this board
	 * @param none
	 * @return	1 - player 1 won
	 * 			2 - player 2 won
	 * 			0 - draw
	 * 		   -1 - the game has not yet ended
	 */
	public int getWinner(){
		if (isOver)	return winner;
		else return -1;
	}

	/**
	 * <p> Method: isOver  
	 * <p> Description:  determines if the game is over,
	 * 			depending on whether the board is full, or
	 * 			if a winner has already been determined
	 * @param none
	 * @return true if the game has ended
	 */
	public boolean isOver(){
		if (this.isFull() || winner>0) isOver = true; 
		return isOver;
	}

	/**
	 * <p> Method: playerAt  
	 * <p> Description:  returns the number of the player that
	 * 			has played at the given location
	 * @param row, col - the row and column of the spot
	 * @return  	1 - player one played
	 * 			2 - player 2 played
	 * 			0 - no one has yet played that spot
	 */
	public int playerAt(int row, int col){
		return board[row][col];
	}

	/**
	 * <p> Method:  isFull
	 * <p> Description:  determines whether this board is full
	 * @param none
	 * @return true if there are no empty spaces
	 */
	public boolean isFull(){
		int emptySpaces = 0;
		for (int i=0; i<board.length; i++){
			for (int j=0; j<board.length; j++){
				if(board[i][j] == DRAW) emptySpaces++;
			}
		}
		return (emptySpaces==0);
	}

	/* (non-Javadoc)
	 * @see java.lang.Object#hashCode()
	 */
	public int hashCode(){
		String hashStr = "";

		for (int i=0; i<board.length; i++){
			for (int j=0; j<board.length; j++){
				hashStr += board[i][j];
			}
		}

		int hashInt = Integer.parseInt(hashStr, 3);

		return hashInt;
	}

	/**
	 * <p> Method:  printBoard
	 * <p> Description:  Prints the board to the screen legibly
	 * @param none
	 * @return none
	 */
	public void printBoard(){
		String boardStr = "";

		for (int i=0; i<board.length; i++){
			for (int j=0; j<board.length; j++){
				switch(playerAt(i, j)){
				case DRAW:	boardStr+="-"; break;
				case PLAYER_1: boardStr+=PLAYER_1_MARK; break;
				case PLAYER_2: boardStr+=PLAYER_2_MARK; break;
				}	
			}
			boardStr+="\n";
		}
		System.out.print(boardStr);;
	}

	/**
	 * <p> Method:  equals
	 * <p> Description:  compares the given TicTacToe board with the current board
	 * 						using their unique hashcode values
	 * @param aBoard - the board to which this one is being compared
	 * @return true or false; whether or not they are the same
	 */
	public boolean equals(Object aBoard){
		TicTacToe aBoardNew = (TicTacToe) aBoard;
		return this.hashCode() ==  aBoardNew.hashCode();
	}

	public String toString(){
		String returnStr = "";

		for (int i=0; i<board.length; i++){
			for (int j=0; j<board.length; j++){
				switch(playerAt(i, j)){
				case DRAW:	returnStr+="-"; break;
				case PLAYER_1: returnStr+=PLAYER_1_MARK; break;
				case PLAYER_2: returnStr+=PLAYER_2_MARK; break;
				}	
			}
			returnStr+="\n"; //change back to " "
		}
		return returnStr;
	}

	//Copy constructor
	public TicTacToe(TicTacToe t){
		for (int i=0; i<t.length; i++)
			for(int j=0; j<t.length; j++)
				this.board[i][j] = t.playerAt(i,j);
		
		this.turnNum = t.getTurnNum();
	}

	public int numEmpty(){
		int emptySpaces = 0;
		for (int i=0; i<board.length; i++){
			for (int j=0; j<board.length; j++){
				if(board[i][j] == DRAW) emptySpaces++;
			}
		}
		return emptySpaces;
	}
	
	public int getTurnNum(){
		return this.turnNum;
	}
	
		public static void main(String[] args){
			TicTacToe testBoard1 = new TicTacToe();
			testBoard1.move(0, 0);
			
			TicTacToe testBoard2 = new TicTacToe();
			testBoard2.move(0, 0);
			
			System.out.println(testBoard1.equals(testBoard2));
			
		}

}


**************

package proj4;

import java.util.ArrayList;
import java.util.Random;

/**
 * @author Rachael Birky
 * @version 04.23.14
 * 
 * <p> SmartPlayer.java
 * <p> This class represents a "smart" TicTacToe player.
 * 		It keeps track of moves it has already made using a hash table,
 * 		and tries to choose the next move that results in the most wins,
 * 		least losses, or random.
 */
public class SmartPlayer {

	boolean debug = true;

	Random generator = new Random();

	private int PLAYER_NUM;

	//stores keys
	private ArrayList<TicTacToe> thisGame = new ArrayList<TicTacToe>();

	private HashTable<TicTacToe, Stats> boards = new HashTable<TicTacToe, Stats>(283);


	public SmartPlayer(int playerNum){
		PLAYER_NUM = playerNum;
	}

	private int getNumSuccessors(TicTacToe t){
		return t.numEmpty();
	}
	
	private TicTacToe[] getSuccessors(TicTacToe t){
		TicTacToe tCopy1 = new TicTacToe(t);
		int numSuccessors = t.numEmpty();
		TicTacToe[] successors = new TicTacToe[9];

		int index=0;
		for(int i=0; i<tCopy1.length; i++){
			for(int j=0; j<tCopy1.length; j++){
				if (tCopy1.playerAt(i, j) == 0){
					tCopy1.move(i,j);
					TicTacToe tCopy2 = new TicTacToe(t);
					tCopy2.move(i, j);
					successors[index] = tCopy2;
					index++;
				}
			}
		}
//		return boards.get(t).getSuccessors();
		return successors;
	}

	public void move(TicTacToe t){

		TicTacToe tCopy = new TicTacToe(t);

		//put given board in hash table to generate or access its successors
//		if(boards.containsKey(t)){
//			boards.get(t).incrementNumSeen();
//		}
//		else{
//			boards.put(tCopy, new Stats(tCopy));
//			boards.get(tCopy).incrementNumSeen();
//		}

		int numSuccessors = getNumSuccessors(t);
		TicTacToe[] successors = getSuccessors(tCopy);

		//if zero successors, game is over, so skip all this!
		if(numSuccessors>0){
			TicTacToe nextMove = null;
			int maxScore = 0;
			ArrayList<TicTacToe> tiedBoards = new ArrayList<TicTacToe>();

			//store successors in hash table to access statistics later
			for(int i=0; i<numSuccessors; i++){
				//if (!boards.containsKey(successors[i])){
					boards.put(successors[i], new Stats(successors[i]));
				//}

				//compare to current max score
				if (boards.get(successors[i]).getPercentWin() > maxScore){
					maxScore = boards.get(successors[i]).getPercentWin();
					nextMove = successors[i];
				}
			}
			
			//put all with same score into an array
			for(int i=0; i<numSuccessors; i++){
				if(boards.get(successors[i]).getPercentWin() == maxScore)
					tiedBoards.add(successors[i]);
			}

			//break tie if need be
			if(tiedBoards.size()>1){
				nextMove = tiedBoards.get(generator.nextInt(tiedBoards.size()));
			}
			else if (tiedBoards.size()==1){
				nextMove = tiedBoards.get(0);
			}

			nextMove = successors[0];
			
			//calculate the spot to move by finding difference, and actually move...
			int row=0; int col=0;
			for (int i=0; i<nextMove.length; i++){
				for (int j=0; j<nextMove.length; j++){
					if (nextMove.playerAt(i, j) != t.playerAt(i, j))
					{row = i; col = j;}
				}
			}
			t.move(row, col);

			//store resulting board in thisGame and hashTable
			TicTacToe result = new TicTacToe(t);
			thisGame.add(result);
			
			//storing duplicates?
			if(boards.containsKey(result)){
				boards.get(result).incrementNumPlayed();
			}
			else{
				boards.put(result, new Stats(result));
				boards.get(result).incrementNumPlayed();
			}
		}
	}

	public void endGame(TicTacToe finalBoard){
		int winner = finalBoard.getWinner();
		System.out.println("winner num: "+winner);
		System.out.println("this player: "+PLAYER_NUM);

		if (winner == PLAYER_NUM){
			for (TicTacToe aBoard : thisGame){
				boards.get(aBoard).incrementNumWins();
				if (debug) {System.out.println("wins"+boards.get(aBoard).getNumWins());}
			}
		}
		else if(winner == 0){
			for (TicTacToe aBoard : thisGame){
				boards.get(aBoard).incrementNumDraws();
				if (debug) {System.out.println("draws"+boards.get(aBoard).getNumDraws());}
			}
		}
		else{
			for (TicTacToe aBoard : thisGame){
				boards.get(aBoard).incrementNumLosses();
				if (debug) {System.out.println("losses"+boards.get(aBoard).getNumLosses());}
			}
		}

		for (TicTacToe aBoard : thisGame){
			if (debug) {System.out.println("wins,losses,draws,numplayed:"+boards.get(aBoard).getNumWins()+","+boards.get(aBoard).getNumLosses()+","+boards.get(aBoard).getNumDraws()+","+boards.get(aBoard).getNumPlayed());}
		}
		
		thisGame = new ArrayList<TicTacToe>();
	}

	public void newGame(int player){
		PLAYER_NUM = player;
		thisGame.clear();
	}

	public int numberOfTimesSeen(TicTacToe t){
		Stats thisStat = boards.get(t);
		int numSeen = thisStat.getNumSeen();
		return numSeen;
	}

	public int getNumSlots(){
		return boards.numSlots();
	}

	public int getNumEntries(){
		return boards.numEntries();
	}

	public int getNumCollisions(){
		return boards.numCollisions();
	}

	public int getPlayerNum(){
		return this.PLAYER_NUM;
	}

	public String toString(){
		return "Smart Player";
	}

	public void printHashTable(){
		boards.printHashTable();
	}

	public void printThisGame(){
		for (TicTacToe aBoard : thisGame)
			System.out.println(aBoard);
	}

	public static void main(String[] args){

		RandomAI p1 = new RandomAI();
		SmartPlayer p2 = new SmartPlayer(2);
		
		for(int i = 0; i<2; i++){
			TicTacToe aBoard = new TicTacToe();

			
			aBoard.move(0, 0);
			aBoard.printBoard();
			
			while(!aBoard.isOver()){
				p2.move(aBoard);
				aBoard.printBoard();
				System.out.println();
				p1.move(aBoard);
				aBoard.printBoard();
				System.out.println();
			}
			p2.endGame(aBoard);
			p2.printHashTable();
			System.out.println("*********");
		}
		
		p2.printHashTable();
		
	}

}


*********************
package proj4;

import java.util.ArrayList;
import java.util.Random;

/**
 * @author Rachael Birky
 * @version 04.23.14
 * 
 * <p> SmartPlayer.java
 * <p> This class represents a "smart" TicTacToe player.
 * 		It keeps track of moves it has already made using a hash table,
 * 		and tries to choose the next move that results in the most wins,
 * 		least losses, or random.
 */
public class SmartPlayer {

	boolean debug = true;

	Random generator = new Random();

	private int PLAYER_NUM;

	//stores keys
	private ArrayList<TicTacToe> thisGame = new ArrayList<TicTacToe>();

	private HashTable<TicTacToe, Stats> boards = new HashTable<TicTacToe, Stats>(283);


	public SmartPlayer(int playerNum){
		PLAYER_NUM = playerNum;
	}

	public void endGame(TicTacToe finalBoard){
		int winner = finalBoard.getWinner();
		System.out.println("winner num: "+winner);
		System.out.println("this player: "+PLAYER_NUM);

		if (winner == PLAYER_NUM){
			for (TicTacToe aBoard : thisGame){
				boards.get(aBoard).incrementNumWins();
				if (debug) {System.out.println("wins"+boards.get(aBoard).getNumWins());}
			}
		}
		else if(winner == 0){
			for (TicTacToe aBoard : thisGame){
				boards.get(aBoard).incrementNumDraws();
				if (debug) {System.out.println("draws"+boards.get(aBoard).getNumDraws());}
			}
		}
		else{
			for (TicTacToe aBoard : thisGame){
				boards.get(aBoard).incrementNumLosses();
				if (debug) {System.out.println("losses"+boards.get(aBoard).getNumLosses());}
			}
		}

		for (TicTacToe aBoard : thisGame){
			if (debug) {System.out.println("wins,losses,draws,numplayed"+boards.get(aBoard).getNumWins()+boards.get(aBoard).getNumLosses()+boards.get(aBoard).getNumDraws()+boards.get(aBoard).getNumPlayed());}
		}
		
		thisGame.clear();
	}

	private TicTacToe[] getSuccessors(TicTacToe t){
		return boards.get(t).getSuccessors();
	}

	public void move(TicTacToe t){

		TicTacToe tCopy = new TicTacToe(t);

		//put given board in hash table to generate or access its successors
		if(boards.containsKey(t)){
			boards.get(t).incrementNumSeen();
		}
		else{
			boards.put(tCopy, new Stats(tCopy));
			boards.get(tCopy).incrementNumSeen();
		}

		int numSuccessors = boards.get(tCopy).getNumSuccessors();
		TicTacToe[] successors = getSuccessors(tCopy);

		//if zero successors, game is over, so skip all this!
		if(numSuccessors>0){
			TicTacToe nextMove = null;
			int maxScore = 0;
			ArrayList<TicTacToe> tiedBoards = new ArrayList<TicTacToe>();

			//store successors in hash table to access statistics later
			for(int i=0; i<numSuccessors; i++){
				//add to hash table if need be
				if (!boards.containsKey(successors[i])){
					boards.put(successors[i], new Stats(successors[i]));
				}
				System.out.println(boards.get(successors[i]).getPercentWin());
				//compare to current max score
				if (boards.get(successors[i]).getPercentWin() > maxScore){
					maxScore = boards.get(successors[i]).getPercentWin();
					nextMove = successors[i];
				}
			}
			

			//put all with same score into an array
			for(int i=0; i<numSuccessors; i++){
				if(boards.get(successors[i]).getPercentWin() == maxScore)
					tiedBoards.add(successors[i]);
			}

			//break tie if need be
			if(tiedBoards.size()>1){
				nextMove = tiedBoards.get(generator.nextInt(tiedBoards.size()));
			}
			else if (tiedBoards.size()==1){
				nextMove = tiedBoards.get(0);
			}

			
			//calculate the spot to move by finding difference, and actually move...
			int row=0; int col=0;
			for (int i=0; i<nextMove.length; i++){
				for (int j=0; j<nextMove.length; j++){
					if (nextMove.playerAt(i, j) != t.playerAt(i, j))
					{row = i; col = j;}
				}
			}
			t.move(row, col);

			//store resulting board in thisGame and hashTable
			TicTacToe result = new TicTacToe(t);
			thisGame.add(result);
			
			if(boards.containsKey(result)){
				boards.get(result).incrementNumPlayed();
			}
			else{
				boards.put(result, new Stats(result));
				boards.get(result).incrementNumPlayed();
			}
		}
	}


	public void newGame(int player){
		PLAYER_NUM = player;
		thisGame.clear();
	}

	public int numberOfTimesSeen(TicTacToe t){
		Stats thisStat = boards.get(t);
		int numSeen = thisStat.getNumSeen();
		return numSeen;
	}

	public int getNumSlots(){
		return boards.numSlots();
	}

	public int getNumEntries(){
		return boards.numEntries();
	}

	public int getNumCollisions(){
		return boards.numCollisions();
	}

	public int getPlayerNum(){
		return this.PLAYER_NUM;
	}

	public String toString(){
		return "Smart Player";
	}

	public void printHashTable(){
		boards.printHashTable();
	}

	public void printThisGame(){
		for (TicTacToe aBoard : thisGame)
			System.out.println(aBoard);
	}

	public static void main(String[] args){

		for(int i = 0; i<2; i++){
			TicTacToe aBoard = new TicTacToe();
			RandomAI p1 = new RandomAI();
			SmartPlayer p2 = new SmartPlayer(2);
			
			while(!aBoard.isOver()){
				p1.move(aBoard);
				aBoard.printBoard();
				System.out.println();
				p2.move(aBoard);
				aBoard.printBoard();
				System.out.println();
			}
			p2.endGame(aBoard);
			System.out.println(p2.getNumSlots());
			System.out.println("*********");
		}
	}

}


******************************

	public void endGame(TicTacToe finalBoard){
		int winner = finalBoard.getWinner();
		System.out.println(winner);
		System.out.println(PLAYER_NUM);

		if (winner == PLAYER_NUM){
			for (TicTacToe aBoard : thisGame){
				boards.get(aBoard).incrementNumWins();
				if (debug) {System.out.println("wins"+boards.get(aBoard).getNumWins());}
			}
		}
		else if(winner == 0){
			for (TicTacToe aBoard : thisGame){
				boards.get(aBoard).incrementNumDraws();
				if (debug) {System.out.println("draws"+boards.get(aBoard).getNumDraws());}
			}
		}
		else{
			for (TicTacToe aBoard : thisGame){
				boards.get(aBoard).incrementNumLosses();
				if (debug) {System.out.println("losses"+boards.get(aBoard).getNumLosses());}
			}
		}

		for (TicTacToe aBoard : thisGame){
			boards.get(aBoard).incrementNumWins();
			if (debug) {System.out.println("wins,losses,draws,numplayed"+boards.get(aBoard).getNumWins()+boards.get(aBoard).getNumLosses()+boards.get(aBoard).getNumDraws()+boards.get(aBoard).getNumPlayed());}
		}
		
		thisGame.clear();
	}

	private TicTacToe[] getSuccessors(TicTacToe t){
		return boards.get(t).getSuccessors();
	}

	public void move(TicTacToe t){

		TicTacToe tCopy = new TicTacToe(t);

		//put given board in hash table to generate or access its successors
		if(boards.containsKey(t)){
			boards.get(t).incrementNumSeen();

		}
		else{
			boards.put(tCopy, new Stats(tCopy));
			boards.get(tCopy).incrementNumSeen();
		}

		int numSuccessors = boards.get(tCopy).getNumSuccessors();
		TicTacToe[] successors = getSuccessors(tCopy);

		//if zero successors, game is over, so skip all this!
		if(numSuccessors>0){
			TicTacToe nextMove = null;
			int maxScore = 0;
			ArrayList<TicTacToe> tiedBoards = new ArrayList<TicTacToe>();

			//store successors in hash table to access statistics later
			for(int i=0; i<numSuccessors; i++){
				//add to hash table if need be
				if (!boards.containsKey(successors[i])){
					boards.put(successors[i], new Stats(successors[i]));
				}
				if (debug) {System.out.println("numplayed: "+boards.get(successors[i]).getNumPlayed());}
				//compare to current max score
				if (boards.get(successors[i]).getPercentWin() > maxScore){
					maxScore = boards.get(successors[i]).getPercentWin();
					nextMove = successors[i];
				}
			}

			//put all with same score into an array
			for(int i=0; i<numSuccessors; i++){
				if(boards.get(successors[i]).getPercentWin() == maxScore)
					tiedBoards.add(successors[i]);
			}

			//break tie if need be
			if(tiedBoards.size()>1){
				nextMove = tiedBoards.get(generator.nextInt(tiedBoards.size()));
			}
			else if (tiedBoards.size()==1){
				nextMove = tiedBoards.get(0);
			}

			
			//calculate the spot to move by finding difference, and actually move...
			int row=0; int col=0;
			for (int i=0; i<nextMove.length; i++){
				for (int j=0; j<nextMove.length; j++){
					if (nextMove.playerAt(i, j) != t.playerAt(i, j))
					{row = i; col = j;}
				}
			}
			t.move(row, col);

			//store resulting board in thisGame and hashTable
			TicTacToe result = new TicTacToe(t);
			thisGame.add(result);

			if(boards.containsKey(result)){
				boards.get(result).incrementNumPlayed();
			}
			else{
				boards.put(result, new Stats(result));
				boards.get(result).incrementNumPlayed();
			}
		}
	}

**************
*SMART PLAYER*
**************

package proj4;

import java.util.ArrayList;
import java.util.Random;

/**
 * @author Rachael Birky
 * @version 04.23.14
 * 
 * <p> SmartPlayer.java
 * <p> This class represents a "smart" TicTacToe player.
 * 		It keeps track of moves it has already made using a hash table,
 * 		and tries to choose the next move that results in the most wins,
 * 		least losses, or random.
 */
public class SmartPlayer {

	boolean debug = true;

	Random generator = new Random();

	private int PLAYER_NUM;
	private ArrayList<TicTacToe> thisGame = new ArrayList<TicTacToe>();

	private HashTable<TicTacToe, Stats> boards = new HashTable<TicTacToe, Stats>(283);


	public SmartPlayer(int playerNum){
		PLAYER_NUM = playerNum;
	}

	public void endGame(TicTacToe finalBoard){
		int winner = finalBoard.getWinner();

		if (winner == PLAYER_NUM){
			for (TicTacToe aBoard : thisGame){
				boards.get(aBoard).incrementNumWins();
			}
		}
		else if(winner == 0){
			for (TicTacToe aBoard : thisGame){
				boards.get(aBoard).incrementNumDraws();
			}
		}
		else{
			for (TicTacToe aBoard : thisGame){
				boards.get(aBoard).incrementNumLosses();
			}
		}
		
		thisGame.clear();
	}

	private TicTacToe[] getSuccessors(TicTacToe t){
		return boards.get(t).getSuccessors();
	}

	public void move(TicTacToe t){

		TicTacToe tCopy = new TicTacToe(t);

		//put given board in hash table to generate or access its successors
		if(boards.containsKey(t)){
			boards.get(t).incrementNumSeen();

		}
		else{
			boards.put(tCopy, new Stats(tCopy));
			boards.get(tCopy).incrementNumSeen();
		}

		int numSuccessors = boards.get(tCopy).getNumSuccessors();
		TicTacToe[] successors = getSuccessors(tCopy);

		//initialize as null since it might be the end of the game...?
		TicTacToe nextMove = null;

		int maxScore = 0;
		ArrayList<TicTacToe> tiedBoards = new ArrayList<TicTacToe>();

		//store successors in hash table to access statistics later
		for(int i=0; i<numSuccessors; i++){
			//add to hash table if need be
			if (!boards.containsKey(successors[i])){
				boards.put(successors[i], new Stats(successors[i]));
			}
			//compare to current max score
			if (boards.get(successors[i]).getPercentWin()>maxScore){
				maxScore = boards.get(successors[i]).getPercentWin();
				nextMove = successors[i];
			}
		}
		
		//put all with same score into an array
		for(int i=0; i<numSuccessors; i++){
			if(boards.get(successors[i]).getPercentWin() == maxScore)
				tiedBoards.add(successors[i]);
		}

		//break tie if need be
		if(tiedBoards.size()>1){
			nextMove = tiedBoards.get(generator.nextInt(tiedBoards.size()));
		}
		else if (tiedBoards.size()==1)
			nextMove = tiedBoards.get(0);

		//calculate the spot to move, and actually move...
		if(nextMove!=null){
			int row=0; int col=0;
			for (int i=0; i<nextMove.length; i++){
				for (int j=0; j<nextMove.length; j++){
					if (nextMove.playerAt(i, j) != t.playerAt(i, j))
					{row = i; col = j;}
				}
			}
			t.move(row, col);
			
			//store resulting board in thisGame and hashTable
			TicTacToe result = new TicTacToe(t);
			thisGame.add(result);
			
			if(boards.containsKey(result)){
				boards.get(result).incrementNumSeen();
			}
			else{
				boards.put(result, new Stats(result));
				boards.get(result).incrementNumSeen();
			}
		}
	}


	public void newGame(int player){
		PLAYER_NUM = player;
		thisGame.clear();
	}

	public int numberOfTimesSeen(TicTacToe t){
		Stats thisStat = boards.get(t);
		int numSeen = thisStat.getNumSeen();
		return numSeen;
	}

	public int getNumSlots(){
		return boards.numSlots();
	}

	public int getNumEntries(){
		return boards.numEntries();
	}

	public int getNumCollisions(){
		return boards.numCollisions();
	}

	public int getPlayerNum(){
		return this.PLAYER_NUM;
	}

	public String toString(){
		return "Smart Player";
	}

	public void printHashTable(){
		boards.printHashTable();
	}

	public void printThisGame(){
		for (TicTacToe aBoard : thisGame)
			System.out.println(aBoard);
	}

	public static void main(String[] args){

		for(int i = 0; i<5; i++){
			TicTacToe aBoard = new TicTacToe();
			RandomAI p1 = new RandomAI();
			SmartPlayer p2 = new SmartPlayer(2);
			while(!aBoard.isOver()){
				p1.move(aBoard);
				aBoard.printBoard();
				System.out.println();
				p2.move(aBoard);
				aBoard.printBoard();
				System.out.println();
			}
			p2.endGame(aBoard);
			System.out.println("*********");
		}
	}

}


**************************
	public void move(TicTacToe t){

		TicTacToe tCopy = new TicTacToe(t);

		//put given board in hash table to generate its successors
		if(boards.containsKey(t)){
			boards.get(t).incrementNumSeen();
		}
		else{
			boards.put(tCopy, new Stats(tCopy));
			boards.get(tCopy).incrementNumSeen();
		}

		
		Stats thisStat = boards.get(t);
		TicTacToe[] successors = getSuccessors(t);
		int maxScore = 0;
		ArrayList<TicTacToe> tiedBoards = new ArrayList<TicTacToe>();
		TicTacToe nextMove = successors[0];
		TicTacToe aCopy;

		//store successors in hash table to access statistics later
		for(int i=0; i<thisStat.getNumSuccessors(); i++){
			 aCopy = new TicTacToe(successors[i]);
			//add to hash table if need be
			if (!boards.containsKey(successors[i])){
				boards.put(aCopy, new Stats(aCopy));
				if (debug) {System.out.println(boards.get(aCopy).getPercentWin());}
			}
			//compare to current max score
			if (boards.get(aCopy).getPercentWin()>maxScore){
				maxScore = boards.get(aCopy).getPercentWin();
				nextMove = aCopy;
			}
		}

		//NULL ERROR HERE WHEN DOESN'T COMPLETE GAME (95)
		//put all with same score into an array
		for(int i=0; i<thisStat.getNumSuccessors(); i++){
			if(boards.get(successors[i]).getPercentWin() == maxScore)
				tiedBoards.add(successors[i]);
		}

		//break tie if need be
		if(tiedBoards.size()>1){
			nextMove = tiedBoards.get(generator.nextInt(tiedBoards.size()));
		}
		else if (tiedBoards.size()==1)
			nextMove = tiedBoards.get(0);

		//NULL ERROR HERE WHEN COMPLETES GAME (106/107)
		//calculate the spot to move, and actually move...
		int row=0; int col=0;
		for (int i=0; i<nextMove.length; i++){
			for (int j=0; j<nextMove.length; j++){
				if (nextMove.playerAt(i, j) != t.playerAt(i, j))
				{row = i; col = j;}
			}
		}
		t.move(row, col);

		//		//play as random
		//		int row, col;
		//
		//		do{
		//			row = generator.nextInt(3);
		//			col = generator.nextInt(3);
		//		} while (!t.move(row, col));
		//
		//		//once true; move there
		//		t.move(row,  col);

		TicTacToe result = new TicTacToe(t);
		thisGame.add(result);
	}



*************
		
		if(boards.containsKey(t)){
			boards.get(t).incrementNumSeen();
		}
		else{
			boards.put(tCopy, new Stats(tCopy));
			boards.get(tCopy).incrementNumSeen();
		}


*******************


for (int i=0; i<thisStat.getNumSuccessors(); i++){
			Stats thisSuccessor = boards.get(successors[i]);
			if(thisSuccessor.getPercentWin()>maxScore)
				maxScore = thisSuccessor.getPercentWin();
		}
		
		//if multiple have bestMove %, store in array, generate random
		ArrayList<TicTacToe> tiedMoves = new ArrayList<TicTacToe>();

		for(int i = 0; i<thisStat.getNumSuccessors(); i++){
			if (boards.get(successors[i]).getPercentWin() == maxScore)
				tiedMoves.add(successors[i]);
		}

		TicTacToe nextMove;
		
		if (tiedMoves.size()>1){
			int random = generator.nextInt(tiedMoves.size());
			nextMove = tiedMoves.get(random);
		}
		else{
			nextMove = tiedMoves.get(0);
		}
		
		//calculate the spot to move, and actually move...
		int row=0; int col=0;
		for (int i=0; i<nextMove.length; i++){
			for (int j=0; j<nextMove.length; j++){
				if (nextMove.playerAt(i, j) != t.playerAt(i, j))
						{row = i; col = j;}
			}
		}
		t.move(row, col);	


**************************

//WORKING HERE
	public TicTacToe bestMove(TicTacToe aBoard, Stats aStat){
		TicTacToe[] successors = getSuccessors(aBoard);
		int numSuccessors = aStat.getNumSuccessors();
		
		//If no known successors, play randomly
		//Generates random until able to play that spot
		if (numSuccessors == 0){
			int row, col;
			do{
				row = generator.nextInt(3);
				col = generator.nextInt(3);
			} while (!aBoard.move(row, col));
			//move on board
			aBoard.move(row,  col);
			//return edited board as "bestMove"/a successor
			return aBoard;
		}

		if (debug) {System.out.println("Found Successor(s)");}
		//If the board has successors stored
		//Loop through successors to find highest win percent
		TicTacToe bestMove = successors[0];

		//length =/= actual number of items
		for(int i = 0; i<numSuccessors; i++){
			if (boards.get(successors[i]).getPercentWin() > boards.get(bestMove).getPercentWin())
				bestMove = successors[i];
		}

		//if multiple have bestMove %, store in array, generate random, return the board at that number
		ArrayList<TicTacToe> tiedMoves = new ArrayList<TicTacToe>();

		for(int i = 0; i<numSuccessors; i++){
			if (boards.get(successors[i]).getPercentWin() == boards.get(bestMove).getPercentWin())
				tiedMoves.add(successors[i]);
		}

		if (tiedMoves.size()>1){
			int random = generator.nextInt(tiedMoves.size());
			bestMove = tiedMoves.get(random);
		}

		//calculate the spot to move, and actually move...
		int row=0; int col=0;
		for (int i=0; i<bestMove.length; i++){
			for (int j=0; j<bestMove.length; j++){
				if (bestMove.playerAt(i, j) != aBoard.playerAt(i, j))
						{row = i; col = j;}
			}
		}
		aBoard.move(row, col);

		//return resulting board
		return bestMove;
	}


		//updates appropriate win/loss/draw value of each board
		if (finalBoard.getWinner() == PLAYER_NUM){
			if (debug) {System.out.println("Updating Wins");}
			for (TicTacToe aBoard : thisGame){
				boards.get(aBoard).incrementNumWins();
				if (debug)System.out.println(aBoard+"numWins: "+boards.get(aBoard).getNumWins());
			}
		}
		else if (finalBoard.getWinner() == 0){
			if (debug) {System.out.println("Updating Draws");}
			for (TicTacToe aBoard : thisGame){
				boards.get(aBoard).incrementNumDraws();
				if (debug)System.out.println(aBoard+"numDraws: "+boards.get(aBoard).getNumDraws());
			}
		}
		else{
			if (debug) {System.out.println("Updating Losses");}
			for (TicTacToe aBoard : thisGame){
				boards.get(aBoard).incrementNumLosses();
				if (debug)System.out.println(aBoard+"numLosses: "+boards.get(aBoard).getNumLosses());
			}
		}	